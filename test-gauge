#!/usr/bin/env python3
"""Run the Gauge specification suite."""

from __future__ import annotations

import argparse
import subprocess
import sys
from collections.abc import Sequence

from tests.test_support import ROOT_DIR, build_test_environment, locate_gauge


def parse_arguments(argv: Sequence[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Execute Gauge specs using the repository configuration.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--specs-dir",
        default="specs",
        help="Path to the Gauge specifications to run.",
    )
    parser.add_argument(
        "gauge_args",
        nargs=argparse.REMAINDER,
        help="Additional arguments forwarded to 'gauge run' (prefix with --).",
    )
    args = parser.parse_args(argv)
    if args.gauge_args and args.gauge_args[0] == "--":
        args.gauge_args = args.gauge_args[1:]
    return args


def _generate_failure_report(log_path: Path | None, exit_code: int) -> None:
    """Generate a comprehensive failure report if specs failed or were skipped."""
    # Determine report paths
    reports_dir = ROOT_DIR / "reports" / "html-report"
    html_report_path = reports_dir / "index.html"
    failure_report_path = reports_dir / "gauge-failures.md"

    # Only generate if we have a log file or HTML report to parse
    if not log_path and not html_report_path.exists():
        return

    # Run the failure report generation script
    script_path = ROOT_DIR / "scripts" / "generate_gauge_failure_report.py"
    if not script_path.exists():
        return

    cmd = [sys.executable, str(script_path), "--output", str(failure_report_path)]

    if log_path and log_path.exists():
        cmd.extend(["--log", str(log_path)])

    if html_report_path.exists():
        cmd.extend(["--html-report", str(html_report_path)])

    # Run the script quietly
    try:
        subprocess.run(
            cmd,
            cwd=str(ROOT_DIR),
            check=False,
            capture_output=True,
            text=True,
        )
    except (subprocess.SubprocessError, OSError):
        # Don't fail the main test run if report generation fails
        pass


def main(argv: Sequence[str] | None = None) -> int:
    if argv is None:
        argv = sys.argv[1:]

    args = parse_arguments(list(argv))
    env = build_test_environment()
    env.setdefault("GAUGE_PYTHON_COMMAND", sys.executable)
    env.setdefault("STEP_IMPL_DIR", str(ROOT_DIR / "step_impl"))

    try:
        gauge_cmd = locate_gauge()
    except FileNotFoundError as error:
        print(error.args[0], file=sys.stderr)
        return 1

    command = [gauge_cmd, "run", args.specs_dir, *args.gauge_args]

    # If GAUGE_LOG_FILE is set, capture verbose output to log file
    log_file_path = env.get("GAUGE_LOG_FILE")
    if log_file_path:
        from pathlib import Path
        from datetime import datetime
        import io

        log_path = Path(log_file_path)
        log_path.parent.mkdir(parents=True, exist_ok=True)

        # Write log header
        with log_path.open("w", encoding="utf-8") as log_file:
            timestamp = datetime.utcnow().isoformat() + "Z"
            log_file.write(f"Gauge Specification Execution Log\n")
            log_file.write(f"Started: {timestamp}\n")
            log_file.write(f"Command: {' '.join(command)}\n")
            log_file.write(f"{'=' * 80}\n\n")
            log_file.flush()

            # Run gauge with output going to log file only (suppress verbose console output)
            process = subprocess.Popen(
                command,
                cwd=str(ROOT_DIR),
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                bufsize=1,
                universal_newlines=True,
            )

            # Capture all output to log file, but only show high-level info to console
            # This reduces noise while keeping essential info visible (spec status, summary)
            for line in process.stdout:
                log_file.write(line)
                log_file.flush()
                # Only print high-level summary lines to console:
                # - Spec/scenario status lines (✓, ✗, ✔, ✖)
                # - Summary statistics (Total, Passed, Failed)
                # - Error messages (for missing steps, failures)
                line_stripped = line.strip()
                should_print = (
                    # Status indicators
                    line_stripped.startswith("✓") or
                    line_stripped.startswith("✗") or
                    line_stripped.startswith("✔") or
                    line_stripped.startswith("✖") or
                    # Summary statistics
                    "Total scenarios:" in line_stripped or
                    "Passed:" in line_stripped or
                    "Failed:" in line_stripped or
                    "Summary:" in line_stripped or
                    "Specifications executed:" in line_stripped or
                    # Error/warning messages (missing steps, failures)
                    "No step implementation matches" in line_stripped or
                    "Step failed:" in line_stripped or
                    "FAILED" in line_stripped or
                    # Spec file references (but not detailed step output)
                    (line_stripped.endswith(".spec") and "::" not in line_stripped) or
                    # Scenario-level status lines (spec :: scenario -> status)
                    (line_stripped and "::" in line_stripped and ("->" in line_stripped or "FAILED" in line_stripped or "PASSED" in line_stripped))
                )
                if should_print:
                    print(line, end="")

            return_code = process.wait()

            # Write log footer
            timestamp = datetime.utcnow().isoformat() + "Z"
            log_file.write(f"\n{'=' * 80}\n")
            log_file.write(f"Completed: {timestamp}\n")
            log_file.write(f"Exit code: {return_code}\n")

        # Generate comprehensive failure report
        _generate_failure_report(log_path, return_code)

        return return_code

    # When not logging to file, still generate failure report if there are failures
    result = subprocess.call(command, cwd=str(ROOT_DIR), env=env)
    _generate_failure_report(None, result)
    return result


if __name__ == "__main__":
    raise SystemExit(main())
