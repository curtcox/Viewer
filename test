#!/usr/bin/env python3
"""
Comprehensive test runner for all tests in the project.
Runs all test files and exits with error code 1 if any tests fail.
"""
import os
import sys
import unittest
import subprocess
from pathlib import Path

# Activate virtual environment if it exists
venv_path = Path(__file__).parent / 'venv'
if venv_path.exists():
    # Add venv to Python path - try multiple Python versions
    python_versions = ['python3.12', 'python3.11', 'python3.10', 'python3.9']
    for py_version in python_versions:
        venv_site_packages = venv_path / 'lib' / py_version / 'site-packages'
        if venv_site_packages.exists():
            sys.path.insert(0, str(venv_site_packages))
            break
    
    # Also add the venv bin directory for any executables
    venv_bin = venv_path / 'bin'
    if venv_bin.exists():
        os.environ['PATH'] = str(venv_bin) + ':' + os.environ.get('PATH', '')

# Set up environment for testing
os.environ['DATABASE_URL'] = 'sqlite:///:memory:'
os.environ['SESSION_SECRET'] = 'test-secret-key'
# Don't set REPL_ID to test local auth by default

def discover_test_files():
    """Discover all test files in the project."""
    test_files = []
    project_root = Path(__file__).parent

    # Auth tests that should only run with run_auth_tests.py due to Flask-Login conflicts
    auth_only_tests = {
        'test_auth_integration',
        'test_auth_providers', 
        'test_local_auth',
        'test_auth_templates'
    }

    # Find all test_*.py files
    for test_file in project_root.glob('test_*.py'):
        if test_file.name != 'test':  # Don't include this script itself
            # Skip auth-only tests that have Flask-Login conflicts
            if test_file.stem not in auth_only_tests:
                test_files.append(test_file.stem)

    return sorted(test_files)

def run_tests():
    """Run all tests and return success status."""
    print("ğŸ§ª Running comprehensive test suite...\n")

    # Discover test files
    test_files = discover_test_files()

    if not test_files:
        print("âŒ No test files found!")
        return False

    print(f"ğŸ“‹ Found {len(test_files)} test files:")
    for test_file in test_files:
        print(f"   - {test_file}.py")
    
    print(f"\nğŸ“ Note: Auth tests are segregated and run separately with run_auth_tests.py:")
    auth_tests = ['test_auth_integration', 'test_auth_providers', 'test_local_auth', 'test_auth_templates']
    for auth_test in auth_tests:
        print(f"   - {auth_test}.py")
    print()

    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()

    total_tests = 0
    failed_imports = []

    # Load all test modules
    for test_file in test_files:
        try:
            module = __import__(test_file)
            tests = loader.loadTestsFromModule(module)
            test_count = tests.countTestCases()
            suite.addTests(tests)
            total_tests += test_count
            print(f"âœ… Loaded {test_file}: {test_count} tests")
        except ImportError as e:
            print(f"âŒ Failed to import {test_file}: {e}")
            failed_imports.append(test_file)
        except Exception as e:
            print(f"âŒ Error loading {test_file}: {e}")
            failed_imports.append(test_file)

    if failed_imports:
        print(f"\nâš ï¸  Failed to load {len(failed_imports)} test files:")
        for test_file in failed_imports:
            print(f"   - {test_file}.py")
        print()

    if total_tests == 0:
        print("âŒ No tests could be loaded!")
        return False

    print(f"\nğŸš€ Running {total_tests} tests...\n")

    # Run tests
    runner = unittest.TextTestRunner(
        verbosity=2,
        stream=sys.stdout,
        descriptions=True,
        failfast=False
    )

    result = runner.run(suite)

    # Print detailed summary
    print(f"\nğŸ“Š Test Summary:")
    print(f"   Tests run: {result.testsRun}")
    print(f"   Failures: {len(result.failures)}")
    print(f"   Errors: {len(result.errors)}")
    print(f"   Skipped: {len(result.skipped) if hasattr(result, 'skipped') else 0}")

    if result.failures:
        print(f"\nâŒ Failures ({len(result.failures)}):")
        for i, (test, traceback) in enumerate(result.failures, 1):
            print(f"   {i}. {test}")
            # Extract the assertion error message
            lines = traceback.split('\n')
            for line in lines:
                if 'AssertionError:' in line:
                    print(f"      {line.strip()}")
                    break

    if result.errors:
        print(f"\nğŸ’¥ Errors ({len(result.errors)}):")
        for i, (test, traceback) in enumerate(result.errors, 1):
            print(f"   {i}. {test}")
            # Extract the error message
            lines = traceback.split('\n')
            for line in reversed(lines):
                if line.strip() and not line.startswith(' '):
                    print(f"      {line.strip()}")
                    break

    # Determine overall success
    success = len(result.failures) == 0 and len(result.errors) == 0

    if success:
        print(f"\nğŸ‰ All tests passed!")
    else:
        print(f"\nğŸ’¥ Test suite failed!")
        if result.failures:
            print(f"   - {len(result.failures)} test(s) failed")
        if result.errors:
            print(f"   - {len(result.errors)} test(s) had errors")

    return success

def main():
    """Main entry point."""
    try:
        success = run_tests()
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Test run interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\nğŸ’¥ Unexpected error during test run: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == '__main__':
    main()
