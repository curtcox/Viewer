{
  "label": "GET /AAAAAI9NhSmFBjTlhGZearC74mCjafgn5ZXm6bezJgreNnpfSYHifEFt_LA5MiP3yIWUaaFE54SZtRjJeyYkVfGqzJxBAg.html",
  "captured_at": "2026-01-11T18:35:37Z",
  "preview": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>URL Editor</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\" rel=\"stylesheet\">\n    <style>\n/* URL Editor Styles */\nbody {\n    margin: 0;\n    padding: 0;\n    height: 100vh;\n    overflow: hidden;\n}\n\n.editor-container {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    padding: 1rem;\n}\n\n.header {\n    margin-bottom: 1rem;\n}\n\n.header-content {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n}\n\n.header-text {\n    flex: 1;\n}\n\n.header-actions {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n}\n\n.meta-links {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n    font-size: 0.9rem;\n}\n\n.main-content {\n    display: grid;\n    grid-template-columns: 1fr 2fr 2fr;\n    gap: 1rem;\n    flex: 1;\n    overflow: hidden;\n}\n\n.editor-section, .indicators-section, .preview-section {\n    display: flex;\n    flex-direction: colum",
  "request": {
    "method": "GET",
    "path": "/AAAAAI9NhSmFBjTlhGZearC74mCjafgn5ZXm6bezJgreNnpfSYHifEFt_LA5MiP3yIWUaaFE54SZtRjJeyYkVfGqzJxBAg.html?",
    "url": "http://localhost/AAAAAI9NhSmFBjTlhGZearC74mCjafgn5ZXm6bezJgreNnpfSYHifEFt_LA5MiP3yIWUaaFE54SZtRjJeyYkVfGqzJxBAg.html",
    "headers": [
      {
        "name": "User-Agent",
        "value": "Werkzeug/3.1.5"
      },
      {
        "name": "Host",
        "value": "localhost"
      },
      {
        "name": "Cookie",
        "value": "session=eyJfcGVybWFuZW50Ijp0cnVlLCJjc3JmX3Rva2VuIjoiMjc1M2NmMDc3YmM0MDA0YmM0M2YyZmU2ZjFlNjk1YzEzMDBjZmQyYSJ9.aWPteQ.SIGDJB_vvie-yqKh4OFR88DWVqg"
      }
    ],
    "query": {},
    "body": {
      "encoding": "utf-8",
      "text": ""
    }
  },
  "response": {
    "status_code": 200,
    "mimetype": "text/html",
    "headers": [
      {
        "name": "Content-Type",
        "value": "text/html"
      },
      {
        "name": "Content-Length",
        "value": "36685"
      },
      {
        "name": "ETag",
        "value": "\"AAAAAI9NhSmFBjTlhGZearC74mCjafgn5ZXm6bezJgreNnpfSYHifEFt_LA5MiP3yIWUaaFE54SZtRjJeyYkVfGqzJxBAg\""
      },
      {
        "name": "Last-Modified",
        "value": "Sun, 11 Jan 2026 18:35:33 GMT"
      },
      {
        "name": "Cache-Control",
        "value": "public, max-age=31536000, immutable"
      },
      {
        "name": "Expires",
        "value": "Thu, 31 Dec 2037 23:55:55 GMT"
      },
      {
        "name": "Vary",
        "value": "Cookie"
      },
      {
        "name": "Set-Cookie",
        "value": "session=eyJfcGVybWFuZW50Ijp0cnVlLCJjc3JmX3Rva2VuIjoiMjc1M2NmMDc3YmM0MDA0YmM0M2YyZmU2ZjFlNjk1YzEzMDBjZmQyYSJ9.aWPteQ.SIGDJB_vvie-yqKh4OFR88DWVqg; Expires=Wed, 11 Feb 2026 18:35:37 GMT; HttpOnly; Path=/"
      }
    ],
    "body": {
      "encoding": "utf-8",
      "text": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>URL Editor</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\" rel=\"stylesheet\">\n    <style>\n/* URL Editor Styles */\nbody {\n    margin: 0;\n    padding: 0;\n    height: 100vh;\n    overflow: hidden;\n}\n\n.editor-container {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n    padding: 1rem;\n}\n\n.header {\n    margin-bottom: 1rem;\n}\n\n.header-content {\n    display: flex;\n    justify-content: space-between;\n    align-items: flex-start;\n}\n\n.header-text {\n    flex: 1;\n}\n\n.header-actions {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n}\n\n.meta-links {\n    display: flex;\n    gap: 0.5rem;\n    align-items: center;\n    font-size: 0.9rem;\n}\n\n.main-content {\n    display: grid;\n    grid-template-columns: 1fr 2fr 2fr;\n    gap: 1rem;\n    flex: 1;\n    overflow: hidden;\n}\n\n.editor-section, .indicators-section, .preview-section {\n    display: flex;\n    flex-direction: column;\n    overflow: hidden;\n}\n\n.section-title {\n    font-weight: bold;\n    margin-bottom: 0.5rem;\n    padding: 0.5rem;\n    background: #f8f9fa;\n    border-bottom: 2px solid #dee2e6;\n}\n\n.editor-wrapper {\n    flex: 1;\n    border: 3px solid #007bff;\n    position: relative;\n    overflow: hidden;\n    min-height: 400px;\n    height: 500px;\n    background-color: #f8f9fa;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}\n\n#url-editor {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: #ffffff;\n}\n\n/* Ensure fallback textarea is visible and styled */\n#url-editor textarea {\n    width: 100% !important;\n    height: 100% !important;\n    padding: 12px !important;\n    font-family: 'Courier New', Courier, monospace !important;\n    font-size: 16px !important;\n    line-height: 1.6 !important;\n    border: 2px solid #ced4da !important;\n    resize: none !important;\n    background-color: #ffffff !important;\n    color: #212529 !important;\n    outline: none !important;\n    box-sizing: border-box !important;\n    display: block !important;\n}\n\n.indicators-list {\n    flex: 1;\n    overflow-y: auto;\n    border: 1px solid #dee2e6;\n    padding: 0.5rem;\n}\n\n.indicator-row {\n    display: grid;\n    grid-template-columns: 30px 30px 30px 30px 30px 40px 60px 50px 50px 1fr;\n    gap: 0.25rem;\n    padding: 0.5rem;\n    border-bottom: 1px solid #eee;\n    font-size: 0.85rem;\n    align-items: center;\n}\n\n.indicator-row:last-child {\n    border-bottom: none;\n}\n\n.indicator {\n    text-align: center;\n    padding: 0.25rem;\n    border-radius: 3px;\n    cursor: help;\n}\n\n.indicator.valid {\n    background: #d4edda;\n    color: #155724;\n}\n\n.indicator.invalid {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.indicator.unknown {\n    background: #e2e3e5;\n    color: #383d41;\n}\n\n.indicator.pending {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.indicator-status {\n    text-align: center;\n    padding: 0.25rem;\n    border-radius: 3px;\n    cursor: help;\n    font-size: 0.75rem;\n}\n\n.indicator-status.valid {\n    background: #d4edda;\n    color: #155724;\n}\n\n.indicator-status.invalid {\n    background: #f8d7da;\n    color: #721c24;\n}\n\n.indicator-status.unknown {\n    background: #e2e3e5;\n    color: #383d41;\n}\n\n.indicator-status.pending {\n    background: #fff3cd;\n    color: #856404;\n}\n\n.error-text {\n    color: #721c24;\n}\n\n.indicator-info {\n    padding: 0.25rem 0.125rem;\n    font-size: 0.85rem;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.indicator-preview {\n    padding: 0.25rem;\n    font-family: monospace;\n    font-size: 0.75rem;\n    overflow: hidden;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n}\n\n.indicator-link {\n    text-align: center;\n}\n\n.preview-output {\n    font-family: monospace;\n    white-space: pre-wrap;\n    word-break: break-all;\n    padding: 1rem;\n    border: 1px solid #dee2e6;\n    background: #ffffff;\n    overflow-y: auto;\n    max-height: 200px;\n}\n\n.final-preview-section {\n    margin-top: 1rem;\n    display: flex;\n    flex-direction: column;\n}\n\n\n\n</style>\n</head>\n<body>\n    <div class=\"editor-container\">\n        <div class=\"header\">\n            <div class=\"header-content\">\n                <div class=\"header-text\">\n                    <h2>URL Editor</h2>\n                    <p class=\"text-muted\">Build and test chained server URLs interactively</p>\n                </div>\n                <div class=\"header-actions\">\n                    <button id=\"copy-url-btn\" class=\"btn btn-primary\">\n                        <i class=\"fas fa-copy\"></i> Copy URL\n                    </button>\n                    <button id=\"open-url-btn\" class=\"btn btn-success\">\n                        <i class=\"fas fa-external-link-alt\"></i> Open URL\n                    </button>\n                    <div class=\"meta-links\">\n                        <a href=\"/meta/urleditor.html\" class=\"link-secondary\">Meta Inspector</a>\n                        <a href=\"/history?start=2026%2F01%2F11+18%3A35%3A00\" class=\"link-secondary\">History</a>\n                        <a href=\"/server_events?start=2026%2F01%2F11+18%3A35%3A00\" class=\"link-secondary\">Server Events</a>\n                    </div>\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"main-content\">\n            <div class=\"editor-section\">\n                <div class=\"section-title\">URL Editor</div>\n                <div class=\"editor-wrapper\">\n                    <div id=\"url-editor\"></div>\n                </div>\n            </div>\n            \n            <div class=\"indicators-section\">\n                <div class=\"section-title\" id=\"section-title-text\">Line Indicators</div>\n                <div class=\"indicators-list\" id=\"indicators-list\">\n                    <div class=\"text-muted text-center\">Edit URL to see indicators</div>\n                </div>\n                <div style=\"display: none\">\n                    valid URL path segment\n                    can accept chained input\n                    Content Identifier\n                </div>\n            </div>\n        </div>\n        \n        <div class=\"final-preview-section\">\n            <div class=\"section-title\">Final Output Preview</div>\n            <div id=\"final-output\" class=\"preview-output\">-</div>\n        </div>\n        </div>\n    </div>\n    \n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.0/ace.js\"></script>\n    <script>var INITIAL_URL = \"\";</script>\n    <script>\n/**\n * URL Editor Application\n * \n * Provides interactive editing of chained server URLs with live preview and validation.\n * @param {object} ace - Ace editor instance\n * @param {string} initialUrl - Initial URL to populate the editor\n */\n(function(ace, initialUrl) {\n    'use strict';\n\n    let editor;\n    \n    // Try to initialize Ace editor, fall back to textarea if not available\n    if (typeof ace !== 'undefined' && ace.edit) {\n        try {\n            editor = ace.edit(\"url-editor\");\n            editor.setTheme(\"ace/theme/textmate\");\n            editor.session.setMode(\"ace/mode/text\");\n            editor.setOptions({\n                fontSize: \"14px\",\n                showPrintMargin: false,\n                highlightActiveLine: true,\n                wrap: true\n            });\n            // Set initial content\n            editor.setValue(initialUrl, -1);\n        } catch (e) {\n            console.error(\"Failed to initialize Ace editor:\", e);\n            editor = createFallbackEditor(initialUrl);\n        }\n    } else {\n        console.warn(\"Ace editor not available, using fallback textarea\");\n        editor = createFallbackEditor(initialUrl);\n    }\n    \n    /**\n     * Create a fallback textarea-based editor when Ace is not available\n     */\n    function createFallbackEditor(content) {\n        const editorDiv = document.getElementById(\"url-editor\");\n        editorDiv.innerHTML = '';\n        editorDiv.style.backgroundColor = '#ffffff';\n        editorDiv.style.display = 'block';\n        \n        const textarea = document.createElement('textarea');\n        textarea.id = 'url-editor-textarea';\n        textarea.className = 'url-editor-textarea';\n        textarea.setAttribute('placeholder', 'Enter URL path elements (one per line or separated by /)');\n        textarea.setAttribute('aria-label', 'URL Editor');\n        \n        // Aggressive inline styling to ensure visibility\n        textarea.style.width = '100%';\n        textarea.style.height = '100%';\n        textarea.style.minHeight = '350px';\n        textarea.style.padding = '12px';\n        textarea.style.fontFamily = '\"Courier New\", Courier, monospace';\n        textarea.style.fontSize = '16px';\n        textarea.style.lineHeight = '1.6';\n        textarea.style.border = '2px solid #ced4da';\n        textarea.style.borderRadius = '4px';\n        textarea.style.resize = 'none';\n        textarea.style.backgroundColor = '#ffffff';\n        textarea.style.color = '#212529';\n        textarea.style.display = 'block';\n        textarea.style.boxSizing = 'border-box';\n        textarea.style.outline = 'none';\n        textarea.value = content;\n        \n        editorDiv.appendChild(textarea);\n        \n        // Force focus to make it visible\n        setTimeout(() => textarea.focus(), 100);\n        \n        // Create Ace-compatible wrapper\n        return {\n            getValue: () => textarea.value,\n            setValue: (value) => { textarea.value = value; },\n            session: {\n                on: (event, callback) => {\n                    if (event === 'change') {\n                        textarea.addEventListener('input', callback);\n                    }\n                }\n            }\n        };\n    }\n    \n    // URL Editor Core Logic\n    class URLEditorApp {\n        constructor() {\n            this.editor = editor;\n            this.currentUrl = \"\";\n            this.setupEventListeners();\n            this.updateFromEditor();\n        }\n        \n        setupEventListeners() {\n            // Update on editor change\n            this.editor.session.on('change', () => {\n                this.updateFromEditor();\n            });\n            \n            // Copy URL button\n            document.getElementById('copy-url-btn').addEventListener('click', () => {\n                this.copyCurrentUrl();\n            });\n            \n            // Open URL button\n            document.getElementById('open-url-btn').addEventListener('click', () => {\n                this.openCurrentUrl();\n            });\n            \n            // Listen to hash changes\n            window.addEventListener('hashchange', () => {\n                this.loadFromHash();\n            });\n        }\n        \n        async updateFromEditor() {\n            const editorContent = this.editor.getValue();\n            this.currentUrl = await this.normalizeUrl(editorContent);\n            this.updateHash();\n            this.updateUI();\n        }\n        \n        async normalizeUrl(content) {\n            // Handle CID literal conversion (lines starting with #)\n            // Split into lines directly without redundant replacement\n            const lines = content.split(/\\r\\n|\\n|\\r/);\n            const segments = [];\n            \n            for (let line of lines) {\n                line = line.trim();\n                if (!line) continue;\n                \n                if (line.startsWith('#')) {\n                    // Convert text to CID literal\n                    const cidText = line.substring(1).trim();\n                    const cidPath = await this.textToCidLiteral(cidText);\n                    if (cidPath) {\n                        segments.push(cidPath);\n                    } else {\n                        // If CID generation failed, keep original text for debugging\n                        segments.push(line);\n                    }\n                } else {\n                    segments.push(line);\n                }\n            }\n            \n            // Build URL from segments\n            const url = '/' + segments.join('/');\n            \n            // Clean up multiple slashes\n            return url.replace(/\\/+/g, '/');\n        }\n        \n        toBase64Url(buffer) {\n            // Convert buffer to base64url format (RFC 4648)\n            return btoa(String.fromCharCode.apply(null, new Uint8Array(buffer)))\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_')\n                .replace(/=+$/, '');\n        }\n        \n        encodeLength(length) {\n            // Encode length as 6-byte big-endian integer\n            const bytes = new Uint8Array(6);\n            for (let i = 5; i >= 0; i--) {\n                bytes[i] = length & 0xff;\n                length = length >>> 8;\n            }\n            return this.toBase64Url(bytes.buffer);\n        }\n        \n        async computeCid(content) {\n            // Compute CID from content using the 256t.org algorithm\n            // See: https://github.com/curtcox/256t.org for specification\n            // Format: <6-byte length prefix><content or SHA-512 hash> encoded as base64url\n            const encoder = new TextEncoder();\n            const contentBytes = encoder.encode(content);\n            const length = contentBytes.length;\n            \n            const prefix = this.encodeLength(length);\n            let suffix;\n            \n            if (length <= 64) {\n                // For small content (<= 64 bytes), embed directly\n                suffix = this.toBase64Url(contentBytes.buffer);\n            } else {\n                // For larger content (> 64 bytes), use SHA-512 hash\n                if (!crypto.subtle) {\n                    throw new Error('crypto.subtle not available - requires HTTPS or localhost');\n                }\n                const hashBuffer = await crypto.subtle.digest('SHA-512', contentBytes);\n                suffix = this.toBase64Url(hashBuffer);\n            }\n            \n            return prefix + suffix;\n        }\n        \n        async textToCidLiteral(text) {\n            // Generate a real CID from the text content using 256t.org algorithm\n            // and store it in the backend for later resolution\n            try {\n                const cid = await this.computeCid(text);\n                \n                // Store the CID in the backend so it can be resolved later\n                const response = await fetch('/api/cid/generate', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                    },\n                    body: JSON.stringify({\n                        content: text,\n                        store: true\n                    })\n                });\n                \n                if (!response.ok) {\n                    console.error(`Error storing CID: ${response.status} ${response.statusText}`);\n                    // Note: Returning computed CID even though storage failed\n                    // This may cause issues if the CID is later accessed before manual storage\n                    console.warn('CID will not be resolvable until content is uploaded manually');\n                    return cid;\n                }\n                \n                // Verify the backend computed the same CID\n                const data = await response.json();\n                if (data.cid_value !== cid) {\n                    console.warn(`CID mismatch: computed ${cid}, backend returned ${data.cid_value}`);\n                    // Use backend's CID as it's the authoritative source\n                    return data.cid_value;\n                }\n                \n                return cid;\n            } catch (error) {\n                console.error('Error generating CID from text:', error);\n                return null;\n            }\n        }\n        \n        updateHash() {\n            // Update URL hash without triggering hashchange\n            const newHash = '#' + this.currentUrl;\n            if (window.location.hash !== newHash) {\n                history.replaceState(null, null, newHash);\n            }\n        }\n        \n        loadFromHash() {\n            const hash = window.location.hash;\n            if (hash && hash.length > 1) {\n                const url = hash.substring(1); // Remove #\n                this.editor.setValue(url, -1);\n            }\n        }\n        \n        updateUI() {\n            this.updateIndicators();\n        }\n        \n        updateIndicators() {\n            // Parse segments from the current normalized URL\n            const urlSegments = this.currentUrl ? this.currentUrl.split('/').filter(s => s) : [];\n            const indicatorsList = document.getElementById('indicators-list');\n            \n            if (urlSegments.length === 0) {\n                indicatorsList.innerHTML = '<div class=\"text-muted text-center\">Edit URL to see indicators</div>';\n                document.getElementById('final-output').textContent = '-';\n                return;\n            }\n            \n            // Create line objects from URL segments\n            const lines = urlSegments.map(segment => ({\n                text: segment,\n                isValidSegment: this.isValidPathSegment(segment),\n                // These will be updated asynchronously via fetchMetadata\n                isServer: null,\n                isValidCid: null,\n                supportsChaining: null,\n                language: null\n            }));\n            \n            let html = '';\n            for (let i = 0; i < lines.length; i++) {\n                html += this.renderIndicatorRow(lines[i], i);\n            }\n            indicatorsList.innerHTML = html;\n            \n            // Setup hover listeners for indicators\n            this.setupHoverListeners();\n            \n            // Fetch preview data for each line asynchronously\n            for (let i = 0; i < lines.length; i++) {\n                this.fetchPreviewData(lines, i);\n            }\n            \n            // Update final output with full URL\n            this.fetchFinalOutput();\n        }\n        \n        setupHoverListeners() {\n            const indicators = document.querySelectorAll('.indicator, .indicator-status');\n            const sectionTitle = document.getElementById('section-title-text');\n            const originalTitle = 'Line Indicators';\n            \n            indicators.forEach(indicator => {\n                indicator.addEventListener('mouseenter', (e) => {\n                    const detail = e.target.getAttribute('data-detail');\n                    if (detail) {\n                        sectionTitle.textContent = detail;\n                    }\n                });\n                \n                indicator.addEventListener('mouseleave', () => {\n                    sectionTitle.textContent = originalTitle;\n                });\n            });\n        }\n        \n        isValidPathSegment(text) {\n            // Simple validation - non-empty and URL-safe\n            return text.length > 0 && !/[\\s<>\"]/.test(text);\n        }\n        \n        async fetchMetadata(segment) {\n            // Fetch metadata from /meta/{segment} endpoint\n            try {\n                const response = await fetch(`/meta/${encodeURIComponent(segment)}`);\n                if (!response.ok) {\n                    console.error(`Error fetching metadata for \"${segment}\": ${response.status} ${response.statusText}`);\n                    return null;\n                }\n                return await response.json();\n            } catch (error) {\n                console.error('Error fetching metadata for', segment, error);\n                return null;\n            }\n        }\n        \n        escapeHtml(text) {\n            // Escape HTML to prevent XSS\n            const div = document.createElement('div');\n            div.textContent = text;\n            return div.innerHTML;\n        }\n        \n        updateStatusIndicator(index, status, message) {\n            // Update the status indicator for a specific row\n            // status can be: 'pending', 'valid' (success), or 'invalid' (failure)\n            const statusElement = document.getElementById(`status-${index}`);\n            if (statusElement) {\n                // Remove all status classes\n                statusElement.classList.remove('pending', 'valid', 'invalid', 'unknown');\n                \n                // Add the new status class\n                statusElement.classList.add(status);\n                \n                // Set icon based on status\n                let icon;\n                if (status === 'pending') {\n                    icon = '⏳';\n                } else if (status === 'valid') {\n                    icon = '✓';\n                } else if (status === 'invalid') {\n                    icon = '✗';\n                } else {\n                    icon = '-';\n                }\n                \n                statusElement.textContent = icon;\n                statusElement.setAttribute('data-detail', message);\n                statusElement.title = message;\n            }\n        }\n        \n        renderIndicatorRow(line, index) {\n            const indicators = [\n                { label: 'Valid', value: line.isValidSegment, detail: `Valid path segment: ${line.isValidSegment ? 'Yes - this is a valid URL path segment' : 'No - contains invalid characters'}`, id: `valid-${index}` },\n                { label: 'Server', value: line.isServer, detail: `Server: Loading metadata...`, id: `server-${index}` },\n                { label: 'CID', value: line.isValidCid, detail: `CID: Loading metadata...`, id: `cid-${index}` },\n                { label: 'Chain', value: line.supportsChaining, detail: `Chaining: Loading metadata...`, id: `chain-${index}` },\n                { label: line.language || '-', value: line.language !== '-' && line.language !== null, detail: `Language: Loading metadata...`, id: `lang-${index}` }\n            ];\n            \n            let html = '<div class=\"indicator-row\" data-index=\"' + index + '\">';\n            \n            // Render indicator icons without labels\n            for (const ind of indicators) {\n                const cssClass = ind.value === true ? 'valid' : (ind.value === false ? 'invalid' : 'unknown');\n                const icon = ind.value === true ? '✓' : (ind.value === false ? '✗' : '-');\n                html += `<div class=\"indicator ${this.escapeHtml(cssClass)}\" id=\"${ind.id}\" data-detail=\"${this.escapeHtml(ind.detail)}\">${icon}</div>`;\n            }\n            \n            // Add Status column - starts as unknown (not yet fetched)\n            html += `<div class=\"indicator-status unknown\" id=\"status-${index}\" data-detail=\"Request status: Not started\" title=\"Request status\">-</div>`;\n            \n            // Add Size, Type, View, Preview columns\n            html += `<div class=\"indicator-info\" id=\"size-${index}\">-</div>`;\n            html += `<div class=\"indicator-info\" id=\"type-${index}\">-</div>`;\n            html += `<div class=\"indicator-link\"><a href=\"#\" class=\"btn btn-sm btn-link\" id=\"link-${index}\">View</a></div>`;\n            html += `<div class=\"indicator-preview\" id=\"preview-${index}\">-</div>`;\n            \n            html += '</div>';\n            return html;\n        }\n        \n        async fetchPreviewData(lines, index) {\n            // Set status to pending (yellow)\n            this.updateStatusIndicator(index, 'pending', 'Request in progress...');\n            \n            try {\n                // Fetch metadata for this segment first\n                const segment = lines[index].text;\n                const metadata = await this.fetchMetadata(segment);\n                \n                // Update indicators based on metadata\n                await this.updateIndicatorsFromMetadata(index, segment, metadata, index === lines.length - 1);\n                \n                // Build URL from current line to end (cumulative path with remaining segments)\n                const urlSegments = lines.slice(index).map(l => l.text);\n                const url = '/' + urlSegments.join('/');\n                \n                // Make HEAD request to get size and content-type without downloading full content\n                const response = await fetch(url, { method: 'HEAD' });\n                const contentType = response.headers.get('content-type') || 'unknown';\n                const contentLength = response.headers.get('content-length') || '?';\n                \n                // Fetch input preview - the input this segment receives is the output of the next segment\n                let inputPreview = '';\n                let previewError = null;\n                if (index < lines.length - 1) {\n                    // Build URL for the next segment onwards to get what input this segment receives\n                    const nextSegments = lines.slice(index + 1).map(l => l.text);\n                    const nextUrl = '/' + nextSegments.join('/');\n                    try {\n                        const inputResponse = await fetch(nextUrl);\n                        if (!inputResponse.ok) {\n                            previewError = `HTTP ${inputResponse.status}: ${inputResponse.statusText}`;\n                            inputPreview = `Error: ${previewError}`;\n                        } else {\n                            const inputText = await inputResponse.text();\n                            const PREVIEW_LENGTH = 200;\n                            inputPreview = inputText.substring(0, PREVIEW_LENGTH);\n                            if (inputText.length > PREVIEW_LENGTH) {\n                                inputPreview += '...';\n                            }\n                        }\n                    } catch (error) {\n                        previewError = error.message;\n                        inputPreview = `Error: ${previewError}`;\n                    }\n                }\n                \n                // Update Size column\n                const sizeElement = document.getElementById(`size-${index}`);\n                if (sizeElement) {\n                    sizeElement.textContent = contentLength;\n                    sizeElement.title = `Size: ${contentLength} bytes`;\n                }\n                \n                // Update Type column\n                const typeElement = document.getElementById(`type-${index}`);\n                if (typeElement) {\n                    // Safely extract the short type name from content-type\n                    const typeParts = contentType.split(';')[0].split('/');\n                    const shortType = typeParts.length > 1 ? typeParts.pop() : contentType;\n                    typeElement.textContent = shortType;\n                    typeElement.title = `Content-Type: ${contentType}`;\n                }\n                \n                // Update Preview column - show the input this segment receives\n                const previewElement = document.getElementById(`preview-${index}`);\n                if (previewElement) {\n                    previewElement.textContent = inputPreview;\n                    previewElement.title = inputPreview;\n                }\n                \n                // Update the link to point to this URL\n                const linkElement = document.getElementById(`link-${index}`);\n                if (linkElement) {\n                    linkElement.href = url;\n                    linkElement.onclick = (e) => {\n                        e.preventDefault();\n                        window.open(url, '_blank');\n                    };\n                }\n                \n                // Set status to success (green) if no preview errors occurred\n                if (previewError) {\n                    this.updateStatusIndicator(index, 'invalid', `Request failed: ${previewError}`);\n                } else {\n                    this.updateStatusIndicator(index, 'valid', 'Request completed successfully');\n                }\n            } catch (error) {\n                // Set status to failure (red)\n                this.updateStatusIndicator(index, 'invalid', `Request failed: ${error.message}`);\n                \n                const sizeElement = document.getElementById(`size-${index}`);\n                if (sizeElement) {\n                    sizeElement.textContent = 'Error';\n                    sizeElement.title = error.message;\n                }\n                const typeElement = document.getElementById(`type-${index}`);\n                if (typeElement) {\n                    typeElement.textContent = 'Error';\n                }\n                const previewElement = document.getElementById(`preview-${index}`);\n                if (previewElement) {\n                    // Display failure information instead of preview text\n                    previewElement.textContent = `Failed: ${error.message}`;\n                    previewElement.title = `Request failed: ${error.message}`;\n                    previewElement.classList.add('error-text');\n                }\n            }\n        }\n        \n        async updateIndicatorsFromMetadata(index, segment, metadata, isLastSegment) {\n            // Determine indicator states based on metadata from /meta endpoint\n            let isServer = false;\n            let isValidCid = false;\n            let supportsChaining = false;\n            let language = '-';\n            \n            if (metadata && metadata.resolution) {\n                const res = metadata.resolution;\n                \n                // Check if it's a server (named server)\n                if (res.type === 'server_execution' || res.type === 'server_function_execution') {\n                    isServer = res.available === true;\n                    supportsChaining = res.supports_chaining === true;\n                    language = res.language || '-';\n                }\n                \n                // Check if it's a CID\n                if (res.type === 'cid') {\n                    isValidCid = true;\n                    // If CID has server info (CID contains a server definition), use it\n                    if (res.server) {\n                        language = res.server.language || '-';\n                        supportsChaining = res.server.supports_chaining === true;\n                        isServer = true;  // CID with server definition is also a server\n                    }\n                    // Otherwise, language and server status remain at defaults\n                    // The /meta endpoint should provide all necessary information\n                }\n            }\n            \n            // Update Server indicator\n            // Green if valid server, red if not a server (unless last segment = gray)\n            const serverElement = document.getElementById(`server-${index}`);\n            if (serverElement) {\n                let cssClass, icon, detail;\n                if (isServer) {\n                    cssClass = 'valid';\n                    icon = '✓';\n                    detail = 'Server: Yes - this segment specifies a valid server that can execute code';\n                } else if (isLastSegment) {\n                    cssClass = 'unknown';\n                    icon = '-';\n                    detail = 'Server: Unknown - this is the last segment, server validation not required';\n                } else {\n                    cssClass = 'invalid';\n                    icon = '✗';\n                    detail = 'Server: No - this segment does not specify a valid server';\n                }\n                serverElement.className = `indicator ${cssClass}`;\n                serverElement.textContent = icon;\n                serverElement.setAttribute('data-detail', detail);\n            }\n            \n            // Update CID indicator\n            // Gray if not a CID, green if valid CID with content, red if invalid/unavailable\n            const cidElement = document.getElementById(`cid-${index}`);\n            if (cidElement) {\n                let cssClass, icon, detail;\n                if (isValidCid) {\n                    cssClass = 'valid';\n                    icon = '✓';\n                    detail = 'CID: Yes - this is a valid Content Identifier with available content';\n                } else if (/^AAAAAAA[A-Za-z0-9_-]+$/.test(segment) || segment.startsWith('#')) {\n                    cssClass = 'invalid';\n                    icon = '✗';\n                    detail = 'CID: Invalid - this looks like a CID but the content is not available';\n                } else {\n                    cssClass = 'unknown';\n                    icon = '-';\n                    detail = 'CID: No - this segment is not a Content Identifier';\n                }\n                cidElement.className = `indicator ${cssClass}`;\n                cidElement.textContent = icon;\n                cidElement.setAttribute('data-detail', detail);\n            }\n            \n            // Update Chain indicator\n            // Green if supports chaining, gray if last segment, red otherwise\n            const chainElement = document.getElementById(`chain-${index}`);\n            if (chainElement) {\n                let cssClass, icon, detail;\n                if (supportsChaining) {\n                    cssClass = 'valid';\n                    icon = '✓';\n                    detail = 'Chaining: Yes - this server can accept chained input from previous segments';\n                } else if (isLastSegment) {\n                    cssClass = 'unknown';\n                    icon = '-';\n                    detail = 'Chaining: N/A - this is the last segment, chaining capability not required';\n                } else {\n                    cssClass = 'invalid';\n                    icon = '✗';\n                    detail = 'Chaining: No - this segment cannot accept chained input';\n                }\n                chainElement.className = `indicator ${cssClass}`;\n                chainElement.textContent = icon;\n                chainElement.setAttribute('data-detail', detail);\n            }\n            \n            // Update Language indicator\n            const langElement = document.getElementById(`lang-${index}`);\n            if (langElement) {\n                let cssClass, icon, detail;\n                if (language && language !== '-') {\n                    cssClass = 'valid';\n                    icon = language;\n                    detail = `Language: ${language} - implementation language of this server`;\n                } else {\n                    cssClass = 'unknown';\n                    icon = '-';\n                    detail = 'Language: Unknown - language information not available';\n                }\n                langElement.className = `indicator ${cssClass}`;\n                langElement.textContent = icon;\n                langElement.setAttribute('data-detail', detail);\n            }\n        }\n        \n        async fetchFinalOutput() {\n            try {\n                const url = this.currentUrl || '/';\n                if (url === '/') {\n                    document.getElementById('final-output').textContent = '-';\n                    return;\n                }\n                \n                const response = await fetch(url);\n                const text = await response.text();\n                const preview = text.substring(0, 100);\n                \n                document.getElementById('final-output').innerHTML = `\n                    <code>${this.escapeHtml(preview)}${text.length > 100 ? '...' : ''}</code>\n                    <div class=\"mt-2\"><small class=\"text-muted\">Full length: ${text.length} characters</small></div>\n                `;\n            } catch (error) {\n                document.getElementById('final-output').innerHTML = `\n                    <span class=\"text-danger\">Error: ${this.escapeHtml(error.message)}</span>\n                `;\n            }\n        }\n        \n        copyCurrentUrl() {\n            const url = this.currentUrl || '/';\n            navigator.clipboard.writeText(url).then(() => {\n                alert('URL copied to clipboard!');\n            });\n        }\n        \n        openCurrentUrl() {\n            const url = this.currentUrl || '/';\n            window.open(url, '_blank');\n        }\n    }\n    \n    // Initialize the app\n    const app = new URLEditorApp();\n    \n    // Load initial URL from hash if present\n    if (window.location.hash) {\n        app.loadFromHash();\n    }\n    \n    // Export for testing\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = { URLEditorApp };\n    }\n})(typeof ace !== 'undefined' ? ace : {}, typeof INITIAL_URL !== 'undefined' ? INITIAL_URL : '');\n\n</script>\n</body>\n</html>\n"
    }
  },
  "screenshot": {
    "captured": true,
    "placeholder": false
  }
}