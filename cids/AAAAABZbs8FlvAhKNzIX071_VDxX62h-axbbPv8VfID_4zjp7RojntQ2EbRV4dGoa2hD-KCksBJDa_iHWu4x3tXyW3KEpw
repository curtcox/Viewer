# ruff: noqa: F821, F706
# pylint: disable=undefined-variable
"""HRX server for parsing and serving Human Readable Archive files.

HRX format specification: https://github.com/google/hrx
"""


import json


def _build_source_snippet(archive_text: str, *, header_prefix: str = "<") -> str | None:
    if not isinstance(archive_text, str) or not archive_text:
        return None

    lines = archive_text.splitlines()
    if not lines:
        return None

    first_header_index = None
    for idx, line in enumerate(lines):
        if line.lstrip().startswith(header_prefix):
            first_header_index = idx
            break

    if first_header_index is None:
        start = 0
        end = min(len(lines), 15)
    else:
        start = max(0, first_header_index - 2)
        end = min(len(lines), first_header_index + 8)

    rendered = []
    for i in range(start, end):
        rendered.append(f"{i + 1:>6}: {lines[i]}")
    return "\n".join(rendered)


def _build_error_response(
    *,
    error: str,
    archive: str | None,
    requested_path: str | None,
    exception: Exception | None = None,
    status: int = 500,
) -> dict:
    payload = {
        "error": error,
        "requested_path": requested_path,
        "exception_type": type(exception).__name__ if exception else None,
        "exception": str(exception) if exception else None,
        "source_snippet": _build_source_snippet(archive if isinstance(archive, str) else ""),
    }

    return {
        "output": json.dumps(payload, indent=2, sort_keys=True),
        "content_type": "application/json",
        "status": status,
    }


def main(archive=None, path=None, *, context=None):
    """Parse and serve HRX archive files.

    Args:
        archive: HRX archive string (required)
        path: File path within the archive (optional)
        context: Server execution context (optional)

    Returns:
        Dictionary with 'output' and 'content_type' keys

    Raises:
        ValueError: If archive is not provided or path is not found
    """
    # Import the HRX parser
    from hrx_parser import HRXArchive, HRXParseError

    from cid_storage import resolve_cid_text

    # Resolve CID-or-text input.
    resolved_text = resolve_cid_text(archive)
    if resolved_text is not None:
        archive = resolved_text

    # Validate that archive is provided
    if archive is None or (isinstance(archive, str) and not archive.strip()):
        raise ValueError(
            "HRX archive is required. Usage: hrx(archive, path) where archive is the HRX string."
        )

    # Parse the archive
    try:
        hrx = HRXArchive(archive)
    except HRXParseError as e:
        first_line = None
        if isinstance(archive, str):
            for candidate in archive.splitlines():
                stripped = candidate.strip()
                if stripped:
                    first_line = stripped
                    break

        hint = (
            "This HRX server expects the file-archive HRX format (e.g. '<===> readme.txt')."
        )
        if isinstance(first_line, str) and first_line.startswith("<==>"):
            hint = (
                "This looks like an HTTP-recording HRX entry (e.g. '<==> /users/1 GET'). "
                "Use the gateway test HRX feature with the built-in archive CID, or use an HTTP-HRX parser/server."
            )

        return _build_error_response(
            error=f"Invalid HRX archive: {hint}",
            archive=archive,
            requested_path=str(path) if path is not None else None,
            exception=e,
            status=500,
        )

    def _list_directory(prefix: str) -> list[str]:
        normalized = (prefix or "").lstrip("/")
        if normalized and not normalized.endswith("/"):
            normalized += "/"

        entries: set[str] = set()
        for file_name in hrx.list_files():
            if normalized and not file_name.startswith(normalized):
                continue

            remainder = file_name[len(normalized) :] if normalized else file_name
            if not remainder:
                continue

            first = remainder.split("/", 1)[0]
            if "/" in remainder:
                entries.add(first + "/")
            else:
                entries.add(first)

        return sorted(entries)

    # If no path specified, return list of files
    if path is None or (isinstance(path, str) and not path.strip()):
        entries = _list_directory("")
        return {
            "output": "\n".join(entries) if entries else "",
            "content_type": "text/plain",
        }

    requested = str(path)
    normalized_requested = requested.lstrip("/")

    try:
        if hrx.has_file(normalized_requested):
            content = hrx.get_file(normalized_requested)

            # Return the file content as plain text
            return {
                "output": content,
                "content_type": "text/plain",
            }
    except Exception as e:
        return _build_error_response(
            error="Error serving HRX archive",
            archive=archive,
            requested_path=requested,
            exception=e,
            status=500,
        )

    directory_entries = _list_directory(normalized_requested)
    if directory_entries:
        return {
            "output": "\n".join(directory_entries),
            "content_type": "text/plain",
        }

    root_entries = _list_directory("")
    payload = {
        "error": "Path not found",
        "requested_path": requested,
        "root_entries": root_entries,
    }

    return {
        "output": json.dumps(payload, indent=2, sort_keys=True),
        "content_type": "application/json",
        "status": 404,
    }
